% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bmars_func.R
\name{bass}
\alias{bass}
\title{Bayesian Adaptive Spline Surfaces (BASS)}
\usage{
bass(xx, y, maxInt = NULL, maxInt.func = NULL, xx.func = NULL,
  degree = 1, maxBasis = 1000, npart = NULL, npart.func = NULL,
  nmcmc = 10000, nburn = 9000, thin = 1, g1 = 0, g2 = 0, h1 = 10,
  h2 = 10, a.beta.prec = 1, b.beta.prec = NULL, w1 = 5, w2 = 5,
  temp.ladder = NULL, start.temper = NULL, ncores = 1, curr.list = NULL,
  save.yhat = TRUE, verbose = TRUE)
}
\arguments{
\item{xx}{a data frame or matrix of predictors.  Categorical predictors should be included as factors.}

\item{y}{a response vector (scalar response) or matrix (functional response).}

\item{maxInt}{integer for maximum degree of interaction in spline basis functions.  Defaults to the number of predictors, which could result in overfitting.}

\item{maxInt.func}{(functional response only) integer for maximum degree of interaction in spline basis functions describing the functional response.}

\item{xx.func}{a data frame or matrix of functional variables.}

\item{degree}{degree of splines.  Stability should be examined for anything other than 1.}

\item{maxBasis}{maximum number of basis functions.}

\item{npart}{minimum number of non-zero points in a basis function.  If the response is functional, this refers only to the portion of the basis function coming from the non-functional predictors.  If the only predictors are functional, this is ignored. Defaults to 1, which could result in overfitting.}

\item{npart.func}{same as npart, but for functional portion of basis function.}

\item{nmcmc}{number of RJMCMC iterations.}

\item{nburn}{number of the \code{nmcmc} iterations to disregard.}

\item{thin}{keep every \code{thin} iterations.}

\item{g1}{shape for IG prior on \eqn{\sigma^2}.}

\item{g2}{scale for IG prior on \eqn{\sigma^2}.}

\item{h1}{shape for gamma prior on \eqn{\lambda}.}

\item{h2}{rate for gamma prior on \eqn{\lambda}.}

\item{a.beta.prec}{shape for gamma prior on \eqn{\tau}.}

\item{b.beta.prec}{rate for gamma prior on \eqn{\tau}.}

\item{w1}{nominal weight for degree of interaction.}

\item{w2}{nominal weight for variables.}

\item{temp.ladder}{temperature ladder used for parallel tempering.  The first value should be 1 and the values should decrease.}

\item{start.temper}{when to start tempering (after how many MCMC iterations).}

\item{ncores}{number of cores to use in parallel tempering.  This currently does not work.}

\item{curr.list}{list of starting models (one element for each temperature), likely output from a previous run.}

\item{save.yhat}{logical; should predictions of training data be saved?}

\item{verbose}{logical; should progress be displayed?}
}
\value{
An object of class 'bass'.  The other output will only be useful to the advanced user.  Rather, users may be interested in prediction and sensitivity analysis, which are obtained by passing the entire object to the predict.bass or sobol functions.
}
\description{
Fits a BASS model using RJMCMC.  Optionally uses parallel tempering to improve mixing.  Can be used with scalar or functional response.
}
\details{
Explores BASS model space by RJMCMC.  The BASS model has \deqn{y = f(x) + \epsilon,  \epsilon ~ N(0,\sigma^2)} \deqn{f(x) = a_0 + \sum_{m=1}^M a_m B_m(x)} and \eqn{B_m(x)} is a BASS basis function (tensor product of spline basis functions). We use priors \deqn{a ~ N(0,\sigma^2/\tau (B'B)^{-1})} \deqn{M ~ Poisson(\lambda)} as well as the priors mentioned in the arguments above.
}
\examples{
### univariate example

## simulate data (Friedman function)
f<-function(x){
  10*sin(pi*x[,1]*x[,2])+20*(x[,3]-.5)^2+10*x[,4]+5*x[,5]
}
sigma<-1 # noise sd
n<-500 # number of observations
x<-matrix(runif(n*10),n,10) #10 variables, only first 5 matter
y<-rnorm(n,f(x),sigma)

## fit BMARS
bm<-BMARS(x,y,maxInt=3,nmcmc=20000,nburn=19000)
plot(bm) # plot fit

## prediction
npred<-100
xpred<-matrix(runif(npred*10),npred,10)
pred<-predictBMARS(bm,xpred) # posterior predictive samples
plot(f(xpred),colMeans(pred)); abline(a=0,b=1,col=2) # true values against posterior predictive means

## sobol
ss<-sobolBMARS(bm)
boxplot(ss$S)
boxplot(ss$T)


### functional example

## simulate data (Friedman function with first variable as functional)
sigma<-1 # noise sd
n<-500 # number of observations
nfunc<-50
xfunc<-seq(0,1,length.out=nfunc)
x<-matrix(runif(n*9),n,9) #10 variables (1 functional), only first 5 matter
y<-matrix(f(cbind(rep(xfunc,each=n),kronecker(rep(1,nfunc),x))),nrow=nfunc,byrow=T)+rnorm(n*nfunc,0,sigma)
bm<-BMARS(x,y,xx.func=xfunc,maxInt=3,nmcmc=20000,nburn=19000)
plot(bm)

## prediction
npred<-100
xpred<-matrix(runif(npred*9),npred,9)
ypred<-matrix(f(cbind(rep(xfunc,each=npred),kronecker(rep(1,nfunc),xpred))),nrow=nfunc,byrow=T)
pred<-predictBMARS(bm,xpred) # posterior predictive samples (each is a curve)
matplot(ypred,t(apply(pred,2:3,mean)),type='l',xlab='observed',ylab='mean prediction'); abline(a=0,b=1,col=2) # true values against posterior predictive means
matplot(ypred,type='l') # actual
matplot(t(apply(pred,2:3,mean)),type='l') # mean prediction


## sobol
ss<-sobolBMARS(bm,mcmc.use = 1:10) # speed this up by specifing a few samples (mcmc.use)
boxplot(ss$S)
boxplot(ss$T) # note that the functional variable(s) are appended to the end of the list of variables (labeled 10 here)

ss<-sobolBMARS(bm,mcmc.use=1:10,func.var=1) # speed this up by specifing a few samples (mcmc.use)
dim(ss$S)
matplot(t(apply(ss$S[1,,],2,cumsum)),type='l') # functional sensitivity indices for 1st posterior draw
ss.mean<-apply(ss$S,2:3,mean) # posterior mean functional sensitivity indices
matplot(t(apply(ss.mean,2,cumsum)),type='l')

ss.mean.scale<-apply(ss$S.var,2:3,mean)
matplot(t(apply(ss.mean.scale,2,cumsum)),type='l') # functional partitioning of variance (posterior mean)
}
\seealso{
\link{predict.bass} for prediction and \link{sobol} for sensitivity analysis.
}
\keyword{BMARS}

